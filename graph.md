<h2>16年5月19，周四</h2>
用邻接表保存图信息。<br>
在磁盘中用一下形式保存：<br>
1 beijing 3 2 30 3 60 5 100<br>
2 tianjin 2 1 30 4 200<br>
3 tangshan 1 1 60<br>
4 nanjing 1 2 200<br>
5 jinan 1 1 100<br>
每列开头为顶点编号，顶点名称。<br>
之后:第一个为与该顶点相邻的顶点个数，后面是每个相邻顶点的编号，和边的权值。<br>
<br>
在内存中保存形式为：<br>
用pair<int,int>保存相邻的顶点和权值。<br>
每一个顶点的所有pair都放在一个vector里面。<br>
定义一个Node类，保存顶点信息（顶点编号，顶点名称，指向对应vector的指针）。<br>
Node --> vector(pair(int,int),pair(int,int),...)。<br>
<br>
dijkstra算法时，从源顶点开始，遍历它的邻接表中的顶点，更新每个顶点的distance值，找到最小的那个，重复执行<br>
每执行一次上述逻辑，list_num计数器减一，直到list_num==0为止<br>
<br>
不知道对不对，，，晚上试一下<br>

<h3>22:52</h3>
上述方法可以实现，但要在每个节点上在加一个属性marked，某个节点做过最小距离的节点后，marked置为true，以后就不再处理该节点<br>
源代码放在dijkstra.cpp中<br>
<br>
<h2>16年5月20</h2>
今天520，还在写代码。。。~>_<~<br>
<h3>8:58</h3>
把dijkstra.cpp中加了点注释<br>
下一步把Fibonacci heap 加到该算法中。<br>
加的位置为寻找在S集合中寻找路径最小的顶点过程。<br>
但是我现在觉得，在“松弛”过程中寻找最小距离顶点已经够省时间的了，反正“松弛”也要循环处理邻接表，不在乎多比较一次最小值吧<br>
再看看。。。<br>
另外，dijkstra算法不能处理有负权值的边的图。因为：<br>
若负权值出现在已经处理过的（marked=true）的临界表中的节点对该节点的边上，则不会处理到这个负值信息。<br>
如果要改进，则去掉marked成员，但是这样肯定会出现循环<br>
<h2>16年5月22</h2>
<h3>下午3:55</h3>
重看了一遍《心花路放》，黄渤的演技就是屌。。。<br>
整理下心情，开始写代码<br>
看了一下网络流问题。增广路方法和预流推进重标号方法。<br>
SAP(shortest-Augmenting-Path)：E-K，Dinic算法等实现方式。<br>
