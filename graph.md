<h2>16年5月19，周四</h2>
用邻接表保存图信息。<br>
在磁盘中用一下形式保存：<br>
1 beijing 3 2 30 3 60 5 100<br>
2 tianjin 2 1 30 4 200<br>
3 tangshan 1 1 60<br>
4 nanjing 1 2 200<br>
5 jinan 1 1 100<br>
每列开头为顶点编号，顶点名称。<br>
之后:第一个为与该顶点相邻的顶点个数，后面是每个相邻顶点的编号，和边的权值。<br>
<br>
在内存中保存形式为：<br>
用pair<int,int>保存相邻的顶点和权值。<br>
每一个顶点的所有pair都放在一个vector里面。<br>
定义一个Node类，保存顶点信息（顶点编号，顶点名称，指向对应vector的指针）。<br>
Node --> vector(pair(int,int),pair(int,int),...)。<br>
<br>
dijkstra算法时，从源顶点开始，遍历它的邻接表中的顶点，更新每个顶点的distance值，找到最小的那个，重复执行<br>
每执行一次上述逻辑，list_num计数器减一，直到list_num==0为止<br>
<br>
不知道对不对，，，晚上试一下<br>

<h3>22:52</h3>
上述方法可以实现，但要在每个节点上在加一个属性marked，某个节点做过最小距离的节点后，marked置为true，以后就不再处理该节点<br>
源代码放在dijkstra.cpp中<br>
<br>
<h2>16年5月20</h2>
今天520，还在写代码。。。~>_<~<br>
<h3>8:58</h3>
把dijkstra.cpp中加了点注释<br>
下一步把Fibonacci heap 加到该算法中。<br>
加的位置为寻找在S集合中寻找路径最小的顶点过程。<br>
但是我现在觉得，在“松弛”过程中寻找最小距离顶点已经够省时间的了，反正“松弛”也要循环处理邻接表，不在乎多比较一次最小值吧<br>
再看看。。。<br>
另外，dijkstra算法不能处理有负权值的边的图。因为：<br>
若负权值出现在已经处理过的（marked=true）的临界表中的节点对该节点的边上，则不会处理到这个负值信息。<br>
如果要改进，则去掉marked成员，但是这样肯定会出现循环<br>
<h2>16年5月22</h2>
<h3>下午3:55</h3>
重看了一遍《心花路放》，黄渤的演技就是屌。。。<br>
整理下心情，开始写代码<br>
看了一下网络流问题。增广路方法和预流推进重标号方法。<br>
SAP(shortest-Augmenting-Path)：E-K，Dinic算法等实现方式。<br>
E-K算法在每次找增广路时都执行一次BFS搜索，这样显然时间复杂度太高，有很多步骤冗余。<br>
so，着重看一下Dinic算法<br>
Dinic算法步骤：<br>
1.用BFS建立分层图  注意:分层图是以当前图为基础建立的,所以要重复建立分层图<br>
2.用DFS的方法在分层图中寻找一条由源点到汇点的路径,获得这条路径的流量X<br>
在这一步中，“这条路径的流量X”是指在这条增广路中最小流量的边拥有的流量。<br>
3.根据这条路径修改整个图,将所经之处正向边流量减少X,反向边流量增加X,注意X是非负数<br>
4.重复步骤2,直到DFS找不到新的路径时,重复步骤1<br>
这个博客不错<a href="https://comzyh.com/blog/archives/568/">网络流入门—用于最大流的Dinic算法</a><br>
反向弧是一定要加的，而且随着更广路的改变，反向弧中的剩余流量也要跟着增加。<br>
因为，如果不增加或改变反向弧的话，相当与砍掉了其他流过该节点的流量继续向下走的机会。<br>
要知道，整个图的流量是同时走的，而，算法的执行是一条路径一条路径的计算，<br>这样的模型，就会造成本来是同时有不同的路径同时走的不同的流量产生截断，不能在继续走了。<br>所以一定要有反向弧！！<br>
